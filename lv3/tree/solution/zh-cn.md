{{ self.title() }}

Author: yuxaij@gmail.com

## 算法1：暴力-对树

对于每个询问，暴力求出该联通块，然后暴力枚举每条边即可。

时间复杂度 $O(mn)$。

## 算法2：a=b 的情况

$a=b$ 即表示该路径实际为一个顶点。那么在 $S$ 中加入一个元素 $(a, b, v)$ 等价于在顶点 $a$ 上加权 $v$，而每个询问则求出连通块中顶点的权和即可。

求出连通块中顶点的权和涉及到求解 $k$ 个顶点构成的虚树。将任意顶点提根，并考虑这 $k$ 个顶点的逐级合并，发现这个连通块正好被分割成 $k+r-1$ 条互不相交的路径且 $r < k$，对每条路径求和即可得知答案。而树上单点修改、路径求和为区间加值、单点查询的问题，可以用 DFS 序 + 树状数组维护差分序列实现。

本题中通过我们给出的 $r$ 个顶点，实际上已经完全可知虚树的形态：将这 $r+k$ 顶点，和它们的 LCA 一起按 DFS 序枚举，并用一个栈维护；每次枚举到一个新的顶点时，考虑栈顶是否为该顶点的祖先，若是，则找到一条连通块内的路径，统计答案即可；否则弹出栈顶元素并重复操作。

时间复杂度 $O\left(\left(n+m+k\right)\log n\right)$。

## 算法3：k=2 的情况

考虑路径和连通块的交集。我们可以发现这个交集也是一条路径，而路径上边的个数为顶点个数 $-1$。对于 $S$ 中一条权值为 $v$ 的路径，若我们在其经过的所有顶点上加上 $v$，而所有边上减去 $v$，则对于每个询问，我们只要求出连通块中所有顶点和边的权值和即可。

$k=2$ 时，连通块是一条路径。因此可以很容易地用 DFS 序 + 树状数组维护差分序列求出。

时间复杂度 $O\left(\left(n+mL+k\right)\log n\right)$。

## 满分算法

结合算法 3 和算法 2 即可。

时间复杂度 $O\left(\left(n+mL+k\right)\log n\right)$。

## 关于调试

有关无根树结构题目，一般可以通过换根来调试，以减少工作量。即每次随机选择一个点作为根，运行多次程序并判断是否多次运行的结果相等。

## 算法X：补集转化

考虑减去所有不在联通块内路径的权值和。整个树被连通块分割成若干个部分，若能对每个部分求出完全落于该部分内的路径权值和，即可解决该问题。

考虑 "不存在一条树边的两个顶点分别为连通块所代表的子图中某个度数大于 $1$ 的顶点，和该子图外的某一顶点" 这个条件。将任意顶点提根，可以发现被连通块分割成的部分具有一定的性质。具体地，若将连通块 "收缩一圈"，即去除连通块中所有度数为 $1$ 的顶点，得到一个较小的连通块 $U$，则去除 $U$ 后有根树被分成不超过 $k$ 个部分，且其中至多有一个部分与根相连，其他部分均为该有根树的子树，且 $U$ 与这些子树部分的并也是一个子树。

考虑对于 $U$ 分割后的一个子树部分。求出经过该子树部分内的路径权值和，再减去经过该子树根的所有路径的权值和，即发现为该部分对询问答案的贡献。后者可以 $O(1)$ 求出，至于前者，在每条路径的两个顶点处加上对应权值，并在 LCA 处减去对应权值，之后查询子树权值和即可。可以利用 DFS 序 + 树状数组实现。

再考虑与根相连的部分。这一部分也可以用补集转化，即用所有路径的权值和减去经过 $U$ 与其他部分所构成子树的路径权值和即可。

时间复杂度 $O\left(\left(n+m+k\right)\log n\right)$。

这个数据出起来让人感到很别扭所以就没出。
