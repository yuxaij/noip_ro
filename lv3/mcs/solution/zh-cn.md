{{ self.title() }}

Author: yuxaij@gmail.com

## 思路

对于 $k=1$ 的情况，即为求区间内的最大连续子段和。这个有很多经典做法。
+ 例如用线段树，每个节点维护该节点内的最大连续子段和、从左端点开始的最大连续前缀和，以及从右端点开始的最大连续后缀和。

对于 $k>1$ 的情况，也可以用线段树和类似 $k=1$ 的方法完成。对于每个节点 $t$，维护：
+ $lef_t(k)$ 选择 $k$ 个子区间，且包含 $t$ 节点所对应区间左端点的最大子区间和
+ $rig_t(k)$ 选择 $k$ 个子区间，且包含 $t$ 节点所对应区间右端点的最大子区间和
+ $in_t(k)$ 选择 $k$ 个子区间的最大子区间和
不难看出建立线段树结构的复杂度为 $O(nk^2\log n)$，回答询问的复杂度为 $O(k^2 \log n)$。

当然，利用费用流建模，可以有更好的做法：连续在询问的区间内选择 $k$ 次区间内的最大连续子段和，但每次选择后都要将选择的区间取反。则我们只需要在 $k=1$ 的线段树上维护一个区间取反的操作即可。

**这两类做法都用到了线段树，优势在于可以支持修改操作**。


## 从特殊情况开始

由于本题没有修改，所以可以尝试采取分治/分块一类对静态数据更通用的方法。

可以先从特殊情况来找一些线索。

### 所有询问的左端点都为 $1$
显然，只要对前缀做 DP 即可。

令 $f(i, k)$ 表示前缀 $[1, i]$ 中选了 $k$ 个区间的最大区间和，则有
$$f(i,k) = \begin{cases}
0, &k = 0 \\
\max\left(f(i-1, k), \max_{j < i} \left\{ f(j, k-1)+A_j-A_i \right\}\right), &k>0
\end{cases}$$

令 $g(j,k-1) = f(j,k-1) + A_j$，用前缀和优化有 
$$\begin{aligned}
f(i,k) &= \begin{cases}
0, &k = 0 \\
\max\left(f(i-1, k), G(i,k-1)+A_i \right), &k>0
\end{cases} \\
G(i,k) &= \max_{j < i} \left\{ f(j, k)-A_j \right\}  = \max(G(i-1,k), f(i-1,k) + A_i)
\end{aligned}$$

### 所有询问的区间长度大于 $n/2$

这种情况的意思实际上是：所有询问的区间都包含同一个位置（此处为 $\lceil n/2 \rceil$）。

类似线段树中合并两个儿子节点的思路，只需要从这个所有询问都包含的位置 $t$，向 $n$ 做正向的 DP，以及从 $t-1$ 向 $1$ 做逆向的 DP，然后合并两个 DP 的结果即可。此时注意 DP 要多一维状态来表示是否包含了位置 $t$ / $t-1$。

令逆向的 DP 为 $h(i,k,c)$，其中 $c$ 表示是否选取的区间包含了 $t-1$，则有
$$\begin{aligned}
h(i,k,c) &= \begin{cases}
\text{IMPOSSIBLE}, &k=0, c=1\\ 
0, &k = 0, c = 0 \\
A_{t-1}-A_{i-1}, &k=1, c=1 \\
\max\left(h(i+1, k,c), G'(i,k-1,c)-A_{i-1} \right), &otherwise
\end{cases} \\
G'(i,k,c) &= \max_{j > i} \left\{ h(j, k)+A_{j-1} \right\}  = \max(G'(i+1,k,c), h(i+1,k) + A_i)
\end{aligned}$$

最后合并得到 
$$hf(l, r, k) = \max_{c_1, c_2 \in [0, 1], 0 \leq i \leq k} h(l, i, c_1) + g(r, k-i+[c_1+c_2=2], c_2)$$

即若询问的区间包含 $t$，则我们可以 $O(k)$ 时间内回答。

## 一般情况

若存在询问不经过这个位置 $t$ 会如何？则这个询问的区间要么落在 $[1,t)$，要么落在 $[t,n]$。若所有落在 $[1,t)$ 内的询问都经过同一个位置 $t'$，这些询问都可以经过 $O(tk)$ 的 DP 处理然后 $O(k)$ 回答；否则，我们求出所有经过 $t'$ 询问的答案，然后将其他的答案再根据其落在 $[1,t'), [t', t)$ 的情况继续划分。

简单而言，可以考虑构造一个类似线段树的分治结构，每次以当前区间的中点作为划分，每个区间维护该区间内从划分点向前/向后直到端点的 DP 值。若一个询问过当前区间的中点，则合并两个 DP 值作答；否则考虑这个询问落在哪一边，递归到下层节点，直到发现询问过某一个节点的划分点即可。

如果想完全预处理出整个分治结构，则预处理的时间和空间复杂度均为 $O(nk \log n)$，好处是可以随时处理一个询问。查询一个询问的复杂度为 $O(\log n + k)$。

也可以先读入所有的询问，然后一次性将所有经过 $n/2$ 的询问全部作答；再处理剩余的询问中落在 $[1,n/2)$ 内的部分；最后再处理落在 $[n/2,n]$ 内的部分。可以想象到这是一个类似于在分治结构上 DFS 的过程。

这样做的话，由于一个节点作答后其 DP 数据即可回收，故空间复杂度为 $O(nk)$。时间复杂度分为两部分，一部分是 DP 的复杂度 $O(nk \log n)$，另一部分是将询问分类并下放的复杂度 $O(q \log n)$，还一部分是回答询问的复杂度 $O(qk)$。

### k=1 
最后一个子任务是 $k=1$, $q$ 很大的情况。即需要我们 $O(1)$ 地求出每个询问在哪个节点上被处理。

考虑先将分治结构维护的区间拓展到 $[0, n'=2^c)$，这样分治结构是一个完全二叉树，且深度为 $c+1$。我们令叶子在第 $0$ 层，根在第 $c$ 层。

按以下的 $c+1$ 位二进制给每层的节点标号
```
000000...0001  第 c 层 (1 个节点)
000000...001x  第 c-1 层 (2 个节点)
000000...01xx  第 c-2 层 (4 个节点)
...
001xxx...xxxx  第 2 层 (n'/ 4 个节点)
01xxxxxxxxxxx  第 1 层 (n'/ 2 个节点)
1xxxxxxxxxxxx  第 0 层 (n' 个节点)
```
这个标号方法有很好的性质。基本上所有常用的操作都可以利用位运算完成。当然逆向标号也是一样的。
对于节点 $x$ 来说
```
id(father) = idf(x) = x >> 1
id(lefson) = idl(x) = x << 1
id(rigson）= idr(x) = x << 1 | 1
is_rigson(x) = x & 1
```
令 `s(x)`表示 x 的最高位，则找到两个节点 $x,y$ 的 $lca(x,y)$ 可以按以下方式完成：
```
lca(x, y) = x >> (s(x xor y) + 1)
```
这个 `s(x)` 可以通过预处理，也可以利用下面的倍增方法求出：
```
ext(x,i,j) = (!!(x>>i))<<j // 提取 x 的第 i 位并求出左移 j 位的结果
s(x) = (ext(x,16,4)|ext(x,8,3)|ext(x,4,2)|ext(x,2,1)|ext(x,1,0)) - (x==0)
```
