{{ self.title() }}

Author: yuxaij@gmail.com

## 题解

考虑之前谈到的 Dijkstra 证明。将每个集合中的元素按从小到大的顺序排序 $(e_1, e_2, \dots, e_k)$。若某个方案选择了 $e_i (i>1)$，则将这个方案中的 $e_i$ 替换为 $e_{i-1}$，则我们得到了一个更小的答案。

故可以将每一个方案看做一个顶点。两个顶点之间存在边，当且仅当它们只有一个元素不同，且这个不同的元素在所对应的集合序 $(e_1, e_2, \dots, e_k)$中是相邻关系。

显然，将所有集合的 $e_1$ 选出，是代价最小的方案。从这个方案开始做 Dijkstra，做到第 $k$ 个顶点时停止算法即可。

注意到由于只要做到至多 $k$ 个顶点，且每个顶点的代价只和这个顶点有关（而与路径无关），因此堆内只需要存至多 $k$ 个元素即可。

此外，判定新加的顶点是否已经在堆内有两种方案，第一种是 HASH 解决，第二种是由于一个顶点在前 $k$ 小的话，则任意一个向其有连边的顶点也在前 $k$ 小内，因此我们只需要保留一个顶点向其的连边即可。

将 $k$ 个集合编号，我们找到新加顶点对应方案中，所有选择了某个 $e_i (i>1)$ 的集合中编号最大者，然后从对应 $e_{i-1}$ 的方案连边即可。
