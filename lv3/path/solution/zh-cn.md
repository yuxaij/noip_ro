{{ self.title() }}

Author: yuxaij@gmail.com

## 算法1：暴力-对路径

对于每个询问，暴力枚举 $k$ 条路径，并依次判断每条路径是否包含询问的顶点。

时间复杂度 $O\left(\left(n+m\right)k\right)$。

## 算法2：没有删除操作

考虑权值最小的路径以外的所有顶点，询问这些顶点的答案一定是这条路径的权值，因此可以直接把树变为一条路径。剩下的即为区间覆盖问题，可以用按端点顺序扫描 + STL 来处理得到所有的答案。

时间复杂度 $O\left(\left(n+k\right) \log n + m\right)$。

## 算法3：二分答案

不妨对每个询问二分答案 $r$，然后判断最小的权值是否可能小于等于 $r$。

若最小的权值不小于 $r$，则说明所有权值小于等于 $r$ 的路径都包含 $u$，即这些路径的交集一定不为空且包含询问的顶点。

注意到路径的交集依然为路径，而求两条路径的交集可以做到 $O(1)$，或者 $O(\log n)$（与实现求解 LCA 算法的复杂度级相同）。具体地说，考虑要求两条路径的交集 $(p,q), (u,v)$。不妨分类讨论，则只有三种情况：

+ 不相交
+ 交集部分完全落于 $(p,q)$ 以 LCA 为分割的某一半内
+ 交集穿过 $(p,q)$ 的 LCA。

容易发现这三种情况中，若将 $(p,q), (u,v)$ 两两求 LCA，则得到的 4 个结果中，一定存在两个结果为 LCA(p,q,u,v)，而剩余的两个结果(无论是不是 LCA(p,q,u,v))满足：

+ 若 $(p,q),(u,v)$ 相交,则这两个结果即求得的交集路径的两端
+ 若 $(p,q),(u,v)$ 不相交,则这两个结果相等，且这个结果指向的顶点一定在 LCA 较高的那条路径上，且是 LCA 较低路径的 LCA 的某个祖先（即，这个顶点不在 LCA 较低的路径上）

可以说是非常容易实现的方法。

最后可以利用线段树来维护二分结构。对于本题，由于每次一定删去权值最小的路径，故可以用倍增来替代二分结构。

若用 $O(\log n)$ 的算法求 LCA，则时间复杂度 $O\left(\left(n + k\right)\log n + \left(m+k\right)\log k\log n\right)$。

## 满分算法

在算法 3 的基础上用 $O(1)$ 算法，即转化为 DFS 序上的区间最小值问题来求 LCA 即可。

有必要的话（评测环境的栈空间有限），则需要手写用栈模拟的 DFS。

## 关于调试

有关无根树结构题目，一般可以通过换根来调试，以减少工作量。即每次随机选择一个点作为根，运行多次程序并判断是否多次运行的结果相等。

时间复杂度 $O\left(\left(n + k\right)\log n + \left(m+k\right)\log k\right)$。
