

{{ self.title() }}

Author: yuxaij@gmail.com

## 最小值的情况

不失一般性，假设图 $G$ 连通。如果询问的不是次小值，而是最小值，则经典的做法很多。包括：

1. 对于每个询问 $a,b$，从 $a$ 向 $b$ 跑类似最短路算法的转移 $d_u = \min_{v}\max(d_v, val_{e(v, u)})$。
2. 对于每个询问 $a,b$，先令图 $G' = (V, \varnothing)$，之后将边集 $E$ 中的边按边权从小到大的顺序依次加入图 $G'$ 中。当 $a,b$ 第一次连通时，即找到了最大值最小的路径中所经过的边权最大值。
3. 对于每个询问 $a,b$，容易证明使最大值最小的路径即为 $a,b$ 在原图某个最小生成树上的路径

考察这几个做法的正确性，以及是否可以拓展到本题。

### 算法 1 - 最短路转移

证明分两步：
1. 若 $a \to b$ 的一个最优解为 $p(a=p_0, p_1, p_2, \dots, p_{r-1}, p_r=b)$，则 $a \to p_{r-1}$ 的最优解**小于** $p$。
2. 若 $a \to p_{r-1}$ 的最优解为 $p'(a \to p_{r-1})$，则 $(p' + e(p_{r-1}, p_r)$ 是 $a \to b$ 的一个最优解。

$\lhd$ 这里对于路径的大小判定，除了权值关键字外，我们还加入了路径经过边的个数作为第二关键字，以便于证明。

这个做法实际即 Prim 算法。它的正确性提供了算法 3 的动机。

注意这个证明类似于 Dijkstra 算法的证明而非 Prim 算法的证明：

+ Prim: 对于任意一点，以及与其相连的边中最小权边的任意一条边 $e$，必然存在一个最小生成树包含 $e$。否则显然可以用 $e$ 替换某一条边构成一个生成树，使得新生成树的权值总和不增加。
 
+ Dijkstra: 若 $a \to b$ 的一个最短路径 $p(a=p_0, p_1, p_2, \dots, p_{r-1}, p_r=b)$，则 $p'(a=p_0,p_1, \dots, p_{r-1})$ 是 $a \to p_{r-1}$ 的一个最短路径且 $p' < p$，这里同样双关键字 $(distance(p), |p|)$ 判定。

如果是次大值，不难推广：
+ 若 $a \to b$ 在取次大值的一个最优解为 $p(a=p_0, p_1, p_2, \dots, p_{r-1}, p_r=b)$，则  $a \to p_{r-1}$ 的最优解**小于** $p$。证明考虑最大值与次大值的位置即可：
	+ 若最大值和次大值都在 $p^{(sub)}(a \to p_{r-1})$ 内，则有 $a \to p_{r-1}$ 的最优解不比 $p^{(sub)}(a \to p_{r-1})$ 的解值要大。
	+ 若最大值取为 $e(p_{r-1}, b)$，则 $p^{(sub)}(a \to p_{r-1})$ 的最大值为 $p$ 的次大值 $\to$ 由于次大值的答案比最大值的答案小，故 $a \to p_{r-1}$ 的最优解比 $a \to b$ 的最优解小。
	+ 若次大值取为 $e(p_{r-1}, b)$，则 $p^{(sub)}(a \to p_{r-1})$ 的次大值比 $e(p_{r-1}, b)$ 更小。
+ $a \to b$  的最优解要么由 $a \to p_{r-1}$ 取最大值下的最优解推广而来，要么由 $a \to p_{r-1}$ 取次大值下的最优解推广而来。

### 算法 2 - 判断连通性

显然，当 $a,b$ 在这个加边过程中第一次连通时，存在一条 $a \to b$ 的路径，且这条路径上的最大值不超过(等于)当前最后所加的边权值；而如果存在一条最大值比该路径更小的路径，则说明 $a,b$ 连通的时间点应该更早，矛盾。

这个做法即 Kruskal 算法。它的正确性同样提供了算法 3 的动机。

至于次大值，容易看出，当 $a,b$ 在这个加边过程中第一次，其所对应的连通块被一条还未加入的边直接相连时，存在一条 $a \to b$ 的路径，其次小值不超过(等于)当前最后所加的边权值。

### 算法 3 - 最小生成树

容易证明，若在图 $G$ 中存在一条边 $(u,v)$ 不属于最小生成树 $T$，则其边权不小于 $u,v$ 在 $T$ 的连通路径中所经过的最大边权值。
若图 $G$ 中存在一条 $u \to v$ 的简单路径 $p(u=p_0, p_1, p_2, \dots, p_{r-1}, p_r=v)$，使得该路径上的最大值小于 $u,v$ 在 $T$ 的连通路径上的最大边权值 $val_{e(x,y)}$（其中，$dis(u, x) < dis(u, y)$）。我们不妨将 $e(x,y)$ "提根"，则必然存在某个 $i$ 使得 $p_i$ 在 $x$ 为根的子树内，$p_{i+1}$ 在 $y$ 为根的子树内，此时有 $e(p_i, p_{i+1}) \geq val_{e(x,y)}$，矛盾。

至于次大值，容易证明若路径上存在不止一条边不属于 $T$，则该路径的次大值不小于 $u,v$ 在 $T$ 的连通路径上的次大边权值。

即至多只存在一条边不属于 $T$，且这条边必须在 $u,v$ 在 $T$ 的连通路径上，跨越了最大边值和次大边权值所对应的边。这条边是路径上的最大值。

若次大值是该路径中在 $(a \to b)_T$ 内所有边的最大值，则有一些可行的做法。但实际上次大值的位置难以确定。

### 小结
三个思路都可以拓展，但整体来看，算法 1 本身的效率较低，而算法 3 难以得到较好的效果。

## 拓展算法 2

我们可以预处理出在加边过程中，每加入一条边 $e$ 后，以连通块为顶点所构成的图 $G^{(e)}$。其中 $G^{(e)}$ 的两个顶点 $A,B$ 之间有边，当且仅当在原图 $G$ 中存在一条边 $(u,v)$，满足 $u,v$ 在此时分属于 $A,B$。这一部分的预处理复杂度为 $O(NM)$。

令点 $a$ 在图 $G^{(e)}$ 中所属顶点为 $C^{(e)}(a)$，之后对于一个询问 $a,b$，枚举 $e$，并判断此时 $G^{(e)}$ 中 $C^{(e)}(a), C^{(e)}(b)$ 是否为同一顶点，或者存在边直接相连即可。

不难看出，这个枚举 $e$ 的过程可以用二分答案优化。我们考虑另外两个复杂度瓶颈，求 $C^{(e)}(a)$，以及如何在更低的复杂度下维护 $G^{(e)}$，并在 $C^{(e)}(a), C^{(e)}(b)$ 不同时，快速查询它们在 $G^{(e)}$ 中是否有边直接相连。

### 函数式的并查集

首先考虑求 $C^{(e)}(a)$ 的部分。我们需要做到询问历史上(合并过程中)某一个时刻的并查集以获得两个点所属的连通块。函数式即保证**不修改原有的状态**。

实际上并查集算法所维护的树已经满足这个要求（只要不使用压缩路径的优化）。将连通块 $A$ 所维护的树根合并到 $B$ 所维护的树根时，记录这次合并的时刻。显然，从任何一个节点出发的祖先链，其经过的边权是递增的。查询某一个元素在时刻 $t$ 所属连通块的**代表元素**，只需要沿祖先链中小于 $t$ 的边走到最远的祖先即可。

唯一的问题在于，这个 "沿祖先链走" 的复杂度可能较高。这里可以用到按秩合并的技巧，即定义一个集合上的函数 $f$，满足 
+ 对于任意连通块 $A$，有 $f(A) \geq 1$
+ 合并两个连通块 $A,B$ 时有 $f(A+B) \geq f(A) + f(B)$

然后将 $A,B$ 中 $f$ 值较小者连向较大者即可。

这样等价于，每沿祖先链走一条边，所属连通块的 $f$ 值至少增大一倍。由于最大的连通块 $V$ 的秩值为 $f(V)$，而最小的秩值 $\geq 1$，故从任意顶点(叶子)开始的祖先链长度不会超过 $\lfloor \log f(V) \rfloor$。

容易看出，令连通块 $A$ 的秩 $f(A)$ 等于该连通块内的顶点个数即可满足条件，且 $f(V) = n$，此时的任一祖先链长度不超过 $\lfloor \log n\rfloor$，即查询一个点在某一时刻所属连通块的复杂度为 $O(\log n)$。

### 快速地预处理 $G^{(e)}$ 和查询

接下来考虑如何加速维护 $G^{(e)}$ 和对应的查询。令 $e(u,v)$ 之前最后加入的边为 $e_{pre}$，则 $G^{(e)}$ 和 $G^{(e_{pre})}$ 的区别并不大：
+ 首先令 $G^{(e)}$ 继承 $G^{(e_{pre})}$ 中的所有边和点
+ 对于合并 $C^{(e_{pre})}(u), C^{(e_{pre})}(v)$，我们保留其中的一个顶点，例如 $C^{(e_{pre})}(u)$，并删除另外一个顶点 $C^{(e_{pre})}(v)$，并将其相关的所有边全部重定向到 $C^{(e)}(u)$ 。
+ 结合并差集，我们可以每次将 $u,v$ 中秩更小的一边合并到秩更大的那一边上去，这样就能保证并差集内树根和图顶点的编号保持一致。

问题在于继承和对边重定向的开销可能比较大。可以考虑函数式的思路，即保留已有信息不变，而对于要修改的信息，即在时刻 $t(e)$，将某一条边 $(C^{(e)}(x), C^{(e)}(v))$ 重定向为 $(C^{(e)}(x), C^{(e)}(u))$ 的操作，我们用保留原边，新增一条边的形式实现。对于删除顶点的操作，我们也对原信息做保留。具体地说：

+ 保留原边 $(C^{(e)}(x), C^{(e)}(v)) = (C^{(e_{pre})}(x), C^{(e_{pre})}(v))$ 的同时，新增一条边 $(C^{(e)}(x), C^{(e)}(u))$，同时给这条边存一个出现的时刻 $t(e)$。如果这条边已经存在了，则不做新增的操作。
+ 对于删去的 $C^{(e_{pre})}(v)$，存储其被删去的时刻 $t(e)$。 
+ 对于其他没有任何影响的继承元素，不做任何操作。
	+ 这意味着这些没有影响的元素之间有默认的等式
		+ $C^{(e)}(a) = C^{(e_{pre})}(a)$
		+ $(C^{(e)}(x), C^{(e)}(y)) = (C^{(e_{pre})}(x), C^{(e_{pre})}(y))$

接下来，如果我们想快速复原 $G^{(e)}$，只要删去所有删去时刻在 $t(e)$ 之前的顶点，然后加入所有出现时刻也在 $t(e)$ 之前，且所连接顶点均为被删除的边即可。

由于在构建 $G^{(e)}$ 时，所有在 $G^{(e_{pre})}$ 中的边加入时刻都在 $t(e)$ 之前，枚举所有需要重定向的边可以通过直接访问 $C^{(e_{pre})}(v)$ 此时的边表获得，只要判断另一个顶点是否已经被删除即可。

当然，复原整个 $G^{(e)}$ 还是要一步一步做。但是对于一个查询，即判断两个点 $a,b$ 在某一个图 $G^{(e)}$ 中所对应连通块是否有边相连时，是非常高效的：
+ 用并查集找到 $a,b$ 对应的 $C^{(e)}(a), C^{(e)}(b)$
+ 判断此时是否存在一条边 $(C^{(e)}(a), C^{(e)}(b))$，其出现的时刻在 $t(e)$ 之前。

后者可以将 $(C^{(e)}(a), C^{(e)}(b))$ HASH 到一个较小的范围，相同 HASH 值的元素用链表挂起，即可期望在 $O(1)$ 内快速查询，在 $O(1)$ 内快速新增一个元素。

最后的问题在于，我们新增的开销有多大，即一共可能新增的边数。这个同样可以用按秩合并的角度去分析：
定义一个集合上的函数 $f$，满足 
+ 对于任意连通块 $A$，有 $f(A) \geq 1$
+ 合并两个连通块 $A,B$ 时有 $f(A+B) \geq f(A) + f(B)$
+ 合并得到一个连通块 $X=A+B$ 的代价 $cost(X) \leq f(A)+f(B)$

容易展开得到一个中继点 $X$ 的代价和满足

$$cost(X) \leq f(A) + f(B) \leq \sum_{\text{leaf L of A,B}} f(L)$$

合并的总代价即为所有合并得到的中继点 $X$ 的代价和

$$ \begin{aligned}
\mathrm{TOT\_COST} &= \sum_{X} cost(X) \\
&\leq \sum_{\text{leaf L}} f(L) \times \left(1 + \sum_{\text{parent X of L}} 1\right) \\
&\leq \lfloor \log f(V) + 1\rfloor \sum_{\text{leaf L}} f(L)
\end{aligned}$$

令 $f(A)$ 为 $A$ 所对应连通块中的顶点个数+所有点的度数，显然是一个同时满足并查集和新增开销条件的秩。
