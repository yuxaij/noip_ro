{{ self.title() }}

Author: yuxaij@gmail.com

## 搜索

最暴力的方法是枚举所有排列然后统计答案；当然一个比较显然的优化是按位枚举排列，同时计算 LIS 对应的 DP 数组。

## 一个较为优秀的剪枝

若枚举了当前位置后，已有的最长上升子序列长度为 $m$。如果可以快速判断之后是否可能获得更长的 LIS，即可做一定的剪枝。

由于长度为 $m$ 的最长上升子序列必然是以当前位置结尾的，故只需要判断比当前位置所放元素 $x$ 的值更大的元素是否都已经放置完毕即可。

利用位运算可以 $O(1)$ 判断。令当前已放元素集合的二进制表示为 $S$ (0位为0，从1位开始表示)，则若比 $x$ 大的元素全放置完毕，当且仅当 $S+2^{x} \geq 2^{n+1}$。

## M=2 

先不考虑已知的 $a$，仅求最长上升子序列长度不超过 2 的排列个数（显然，将答案 $-1$ 即为最长上升子序列长度恰好为 2 时的排列个数）。考虑 $n$ 在排列中的哪个位置，不妨假设在位置 $k$。考虑 $n-1$ 此时有哪些可行放置。

+ 若 $n-1$ 放置在位置 $k$ 之前，则 $n-1$ 必然放在最靠前的位置，否则将有长度为 $3$ 的上升子序列 $x, n-1, n-2$。
+ 若 $n-1$ 放置在 $k$ 之后，则由于任何以 $n$ 结尾的上升子序列都可以将 $n$ 用 $n-1$ 替代，即 $n$ 无用；

对于前者，相当于位置 $k$ 的元素 $n$ 将排列分成了两个区域，第一个区域的长度为 $k-1$，第二个区域的长度为 $n-k$，而前者将 $n-1$ 放置在第一个区域且必须放在最靠前的位置，因此第一个区域的长度 $-1$，第二个区域的长度不变；对于后者，由于 $n$ 无用，因此区域被 $n-1$ 的位置 $k'$ 重新划分成长度为 $(k-1) + (k'-k-1), (n-k) - (k'-k)$。

这是一个比较简单的 DP。再考虑已知的排列 $a$，只需要保证：

+ 放置 $a_2$ 时，$a_2$ 不会放在第一个区域
+ 放置 $a_1$ 时，$a_1$ 必须放在第一个区域，且必须保证当前区域中最靠前的位置比 $a_2$ 小

在 DP 中多记录一个状态 $sz1_{a_2}$ 表示放置 $a_2$ 时，第一个区域的大小是多少即可。之后一直到放置 $a_1$ 之前，若一个元素放置在第二区域，则 $sz1_{a_2}$ 不变；若元素放置在第一区域，则 $sz1_{a_2}$ 与当前的第一区域大小同步 $-1$。当放置 $a_1$ 时，判断 $sz1_{a_2}$ 是否大于 $0$ 即可。

## $O(n \log n)$ 求最长上升子序列的算法

一个比较经典的，可在 $O(n \log n)$ 时间内求最长上升子序列的算法为，在 DP 过程中，不直接访问之前每个数的 DP 值，而是对于所有 DP 值为 $i$ 的元素，仅维护其中最小者 $g(i)$ ——显然只有最小者是值得记录的。

更进一步可以得到，$g$ 单调递增。考虑反证。若 $g$ 不单调递增，则必然存在某个 $i$ 使得 $g(i) < g(i-1)$。由于存在长度为 $i$ 的，以 $g(i)$ 结尾的上升子序列，因此去掉这个序列的末尾 $g(i)$，可以得到一个长度为 $i-1$ 的，末尾元素值比 $g(i)$ 更小的上升子序列。这与 $g(i-1) > g(i)$ 矛盾。 

考虑利用这个算法优化搜索过程。

注意到在搜索的任何过程中，一个元素只有三种情况：

+ 还未被放置
+ 已被放置，且是被维护的一个最小者
+ 已被放置，未被维护

而因为被维护的元素是有序的，因此搜索的状态量至多只有 $3^{N}$，记忆化搜索即可。

$\rhd$ **应当注意简化记忆化搜索的细节**。由于记忆化搜索中，任何时刻的具体状态均可利用搜索中的回溯方法维护，故相比普通的搜索，只需要多记录/维护当前状态的表示值。
