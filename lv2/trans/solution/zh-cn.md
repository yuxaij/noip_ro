
{{ self.title() }}

Author: yuxaij@gmail.com

## DP

显然，最终非降序列中的每一个元素必然是由初始序列中的某一个连续段内的所有元素合并而来。更确切地说，令最终序列为 $b(b_1, b_2, \dots, b_m)$，且 $b_i$ 由连续段 $a[l_i \dots r_i]$ 合并而来，则有：

+ $l_1 = 1$
+ $r_i = l_{i+1} - 1$
+ $r_m = n$

即这些连续段互不相交，且并恰好为 $[1 \dots n]$。容易知道，合并的次数即为初始序列 $a$ 与最终序列 $b$ 的大小之差 $n-m$，故我们只需最大化 $b$ 的长度，即最终将 $a$ 拆分成的连续段个数。容易设计出一个原始的 DP 状态 $f(i,j)$ 表示将 $a[1 \dots i]$ 拆分成若干个连续段，且最后一个连续段为 $[j \dots i]$ 时，所能拆出的最多连续段个数。有转移：

$$f(i,j) = \max_{k < j, sum(a[j \dots i]) \geq sum(a[k \dots j-1])} \{ f(j-1, k) + 1 \}$$

<!-- fuck KaTeX that does not support substack -->

## 优化

注意到转移 $f(i,j)$ 时，合法的 $k$，即满足 $k<j$ 且$sum(a[k \dots j-1]) \leq sum(a[j \dots i])$ 条件的 $k$ 集合是一个以 $j-1$ 结尾的连续段 $[kmin, j-1]$，转移时只需要知道 $f(j-1, *)$ 在这个连续段内的最大值即可。

可以切换 DP 的主维度至 $j$ 而非 $i$。由于有 $i \geq j$，因此当我们 DP 至 $f(*, j)$ 时，$f(j-1,*)$ 内的任意一个元素 $f(j-1, k)$ 都满足 $k \leq j-1 < j$，即 $f(j-1,k)$ 已被求出，故此时 $f(j-1, *)$ 已知。

考虑对于每一个 $j$，预处理出 $f(j-1, *)$ 中以 $j-1$ 结尾的所有连续段（或者说，所有的后缀）的最大值。那么对于一个我们此时想求的 $f(i, j)$，所要做的就是找到其对应的 $kmin(i)$，然后 $O(1)$ 提取对应连续段的预处理最大值即可。

每一轮预处理为 $O(n)$，总共做 $O(n)$ 轮；而对于一个给定的 $i$，找对应的 $kmin(i)$ 不难用二分得到——即转移一个 $f(i,j)$ 的复杂度为 $O(\log n)$。

当然，由于随着 $i$ 增大，$[kmin(i), j-1]$ 这个可行集合的大小是增大的，即 $kmin(i)$ 不降，因此也可以直接用一个单调指针来维护 $kmin(i)$。

## 打表

接下来的做法需要一些跳跃性的证明。但是你也可以用打表的方法猜出对应的性质。

## 证明

考虑全局的最优解 $b$ 是 OPT(OPT_1, 
对于每一个 $i$，
