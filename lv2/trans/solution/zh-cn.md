

{{ self.title() }}

Author: yuxaij@gmail.com

## DP

显然，最终非降序列中的每一个元素必然是由初始序列中的某一个连续段内的所有元素合并而来。更确切地说，令最终序列为 $b(b_1, b_2, \dots, b_m)$，且 $b_i$ 由连续段 $a[l_i \dots r_i]$ 合并而来，则有：

+ $l_1 = 1$
+ $r_i = l_{i+1} - 1$
+ $r_m = n$

即这些连续段互不相交，且并恰好为 $[1 \dots n]$。容易知道，合并的次数即为初始序列 $a$ 与最终序列 $b$ 的大小之差 $n-m$，故我们只需最大化 $b$ 的长度，即最终将 $a$ 拆分成的连续段个数。容易设计出一个原始的 DP 状态 $f(i,j)$ 表示将 $a[1 \dots i]$ 拆分成若干个连续段，且最后一个连续段为 $[j \dots i]$ 时，所能拆出的最多连续段个数。有转移：

$$f(i,j) = \begin{cases}
1, & j = 1 \\
\max_{k < j, sum(a[j \dots i]) \geq sum(a[k \dots j-1])} \{ f(j-1, k) + 1 \}, & j > 1
\end{cases}
$$

<!-- fuck KaTeX that does not support substack -->

## 优化

注意到转移 $f(i,j)$ 时，合法的 $k$，即满足 $k<j$ 且$sum(a[k \dots j-1]) \leq sum(a[j \dots i])$ 条件的 $k$ 集合是一个以 $j-1$ 结尾的连续段 $[kmin, j-1]$，转移时只需要知道 $f(j-1, *)$ 在这个连续段内的最大值即可。

可以切换 DP 的主维度至 $j$ 而非 $i$。由于有 $i \geq j$，因此当我们 DP 至 $f(*, j)$ 时，$f(j-1,*)$ 内的任意一个元素 $f(j-1, k)$ 都满足 $k \leq j-1 < j$，即 $f(j-1,k)$ 已被求出，故此时 $f(j-1, *)$ 已知。

考虑对于每一个 $j$，预处理出 $f(j-1, *)$ 中以 $j-1$ 结尾的所有连续段（或者说，所有的后缀）的最大值。那么对于一个我们此时想求的 $f(i, j)$，所要做的就是找到其对应的 $kmin(i)$，然后 $O(1)$ 提取对应连续段的预处理最大值即可。

每一轮预处理为 $O(n)$，总共做 $O(n)$ 轮；而对于一个给定的 $i$，找对应的 $kmin(i)$ 不难用二分得到——即转移一个 $f(i,j)$ 的复杂度为 $O(\log n)$。

当然，由于随着 $i$ 增大，$[kmin(i), j-1]$ 这个可行集合的大小是增大的，即 $kmin(i)$ 不降，因此也可以直接用一个单调指针来维护 $kmin(i)$。

## 打表

接下来的做法需要一些跳跃性的证明。但是你也可以用打表的方法猜出对应的性质。

首先可以想象，对于一个前缀 $a[1 \dots i]$，最后一段拆分得越小，对 $a[i+1 \dots n]$ 的拆分就越有利；同时，能感觉到若最后一段越小，则之前的元素也必须相应地变小，即 "所有拆分成的元素会减小，但由于元素之和是固定的 $sum(a[1 \dots i])$，因此拆分的总段数增加"。

当然，如果最后一段小到一定程度的话，可能会导致无解的情况。事实上，若我们令所有无解的 $f(i,j)=+\infty$，然后分析对于一个给定的 $i$ 时的 $f(i,*)$，可以发现

$$\begin{aligned}
\forall 1 < j < i - 1, \quad &either ~ &f(i,j+1) =& +\infty \\
& or ~ & f(i,j+1) \geq& f(i,j)
\end{aligned}$$

<!-- 不是很严谨的写法 -->

即若最后一段 $a[i \dots j]$ 拆分得越小，$f(i,j)$ 越大。由于最后一段的值越小对之后的拆分就越有利，因此对于给定的 $i$，我们只要保留相应值最大的有解 $f(i, g(i))$ 即可，即最大化可行的 $g(i)$。

令 $last(i) = sum[g(i) \dots i] = A(i) - A(g(i)-1)$，其中 $A(i) = sum(a[1\dots i])$，可以得到转移

$$ f(i, g(i)) = \max_{sum[g(i) \dots i] \geq last(g(i)-1)} f(g(i)-1, g(g(i)-1))$$

用 $k$ 代写 $g(i)$，简化一下这个转移有

$$f(i) = \max_{A(i) \geq 2A(k-1) - A(g(k-1)-1)} f(k-1) + 1$$

其中的 $2A(k-1) - A(g(k-1)-1)$ 是一个只和 $k-1$ 相关的式子 $h(k-1)$。这是一个类似于最长上升子序列的 DP 转移式，我们有经典的 $O(n \log n)$ 算法：对所有值相同的 $f(k-1)$，只存 $h(k)$ 最小者 $minh(f)$；按 $f(k-1)$ 的值域建线段树，询问时只要沿线段树的二分结构从后向前查询第一个比 $A(i)$ 小的位置即可。

## 更进一步

其实还有更显然的单调性。考虑在 $a[1 \dots i]$ 的最优方案中，在最后一个连续段中新增一个 $a[i+1]$，这个方案依然是合法的，且拆分段数不变，故 $i+1$ 的解中总是存在一个拆分段数为 $f(i)$ 的解，即我们有 $f(i+1) \geq f(i)$。

同样的，由于将 $a[1 \dots i+1]$ 的最后一段用 $a[g(i), \dots i+1]$ 拆分存在合法解，而最优解要使得最后一段的拆分尽可能地小，因此我们有 $g(i+1) \geq g(i)$。

$g(i)$ 属于 $f(i)$ 的转移决策单调，这一部分的优化是比较经典的 (totally) monotone matrix, 相关内容，此处留白。

对于 $f(i+1) \geq f(i)$，这意味着只要找满足 $A(i) \geq h(k)$ 的最大的 $k$ 即可。若每次的询问 $A(i)$ 不单调，我们可以维护一个栈 $s(s_1, s_2, \dots, s_{top})$，满足栈内 $s_i < s_{i+1}$ 且 $h(s_{i}) < h(s_{i+1})$，对于每次询问则在栈内二分查到最大的可行 $h(s_j) \leq A(i)$，并用 $f(s_j)$ 更新 $f(i)$。

由于 $A(i)$ 实际上单调不降，因此每次查询得到的 $s_j$ 在栈内的位置(元素值)应是不降的，故可以用一个单调的指针维护当前最后一次查询到的 $s_j$ 位置 $s^{(last)}_j$。

$\rhd$ 注意若加入新元素 $h(i)$ 时栈顶弹出到 $s^{(last)}_j$ 以前的位置，由于 $s_j$ 是不降而非递增，因此 $s^{(last)}_j$ 应仍存于栈中，即此时栈内应存有两个元素：$s^{(i)} = (s^{(last)}_j, i)$。

最终复杂度为 $O(n)$。

## 证明

由于前缀 $a[1 \dots i]$ 依然是一个序列，所以只用对全局证明即可。

设全局的最优解是将序列变换为 $OPT(OPT_1,OPT_2, \dots, OPT_m)$，我们想证明这个最优解保证了 $OPT_m$ 是所有解中末尾连续段和最小的。考虑反证法。假设末尾连续段和最小的解为以 $b_r < OPT_m$ 结尾的解 $b(b_1, \dots, b_r)$ 且 $r < m$。

再考虑 $b_{r-1}$ 和 $OPT_{m-1}$ 。不难发现若 $b_{r-1} + b_r \geq OPT_{m-1} + OPT_{m}$，则我们可以从 $OPT_{m}$ 中分出一些元素给 $OPT_{m-1}$，使得 
$$OPT_{m} \to b_r, \quad OPT_{m-1} \to OPT_{m-1} + OPT_{m} - b_r$$

由于 $b_{r-1} \leq b_r$，我们有
$$OPT^{(new)}_m = b_r > b_{r-1} + b_r - b_r \geq OPT_{m-1} + OPT_m - b_r = OPT^{(new)}_{m-1} $$

故若 $b_{r-1} + b_r \geq OPT_{m-1} + OPT_{m}$，我们可以将 $OPT$ 变化为 $OPT^{(new)}(OPT_1, OPT_2, OPT_{m-2},  OPT_{m-1} + (OPT_{m} - b_r), b_r)$，即存在一个最优解 $OPT^{(new)}$ 的末尾连续段和 $b_r$ 是所有解中最小的。

若 $b_{r-1} + b_r < OPT_{m-1} + OPT_{m}$，我们可以继续按上述方法归纳：对于任意的 $k \in [0, r]$，总有
$$ \sum_{i=0}^{k} b_{r-i} < \sum_{i=0}^{k} OPT_{m-i} $$

而由于 $r < m$，上述条件在 $k = r$ 时是不成立的：
$$ \sum_{i=0}^{r} b_{r-i} = sum(A[1 \dots n]) \geq \sum_{i=0}^{r} OPT_{m-i} $$

Q.E.D.
