{{ self.title() }}

Author: yuxaij@gmail.com

## 各类背包问题的基本算法

0-1 背包的 DP 较为简单，略，令这个 DP 的状态表示为 $F[i,v]$。

完全背包则在 0-1 背包的 DP 上加入一个前缀和转移解决。

一般性的背包问题时，对于第 $i$ 个物品的转移，将 DP 数组沿 $V$ 一维按对 $volume_i$ 取模的结果分为 $volume_i$ 类，其中第 $i$ 类的取模值为 $i-1$。可以看出，转移一类的某个位置 $k$ 时，只需要求出这一类中 $[k-num_i,k]$ 中的一个类似最大值的数值即可。这是一个经典的 SLIDING WINDOW 问题。

## 滚动数组

在不计方案时，转移 $F[i]$ 只和 $F[i-1]$ 有关，转移 $F[i+1]$ 只和 $F[i]$ 有关。因此求出 $F[i]$ 后，转移 $F[i+1]$ 时，将这些数值存储到 $F[i-1]$ 的部分即可，这样即可减少空间复杂度至 $O(V)$。

比较简单的写法是利用两个指针 $f, g$ 指向所对应的实际空间，每次转移下一个 $i+1$ 时，swap($f,g$) 即可。 

## 记录方案

首先考虑字典序的问题。这个问题比较简单，按 $n \to 1$ 的顺序做 DP 即可。这样找字典序最小的最优解时，第一步是找第 1 类物品用得最少的最优解，在逆序的情况下，我们只要知道 $f[1][V]$ 由 $f[2]$ 中的哪些可以转移过来，以及这些中谁是最小的即可。求出第 1 类物品的个数后，剩下的问题是一个 $n$ 规模减一的子问题，重复找即可。

## 滚动数组下记录方案: 0-1 背包

如果是 0-1 背包问题，则可以考虑压位的方法——一个 int 类型可以存储 32 个 0-1 位，因此我们可以直接用 $\lceil{n / 32\rceil}$ 个 int 来存储方案。

在 c++ 中可以直接用 STL 库中的 bitset 做到。

## 滚动数组下记录方案: 一般情况

可以有分块做法，这里直接描述更通用的分治做法。

考虑把 DP 矩阵画出来，一个最优解实际上是从 $(0,0)$ 出发到 $(n,V)$ 的一条路径。

我们考虑把这个路径的中点，即最优解经过的 $(n/2,x)$ 找出来，这个可以直接利用滚动数组做到。

这样路径被分成两部分：从 $(0,0)$ 到 $(n/2,x)$ 的部分，从 $(n/2,x)$ 到 $(n,V)$ 的部分。注意到对于前者，我们只需要在 $(0,0)-(n/2,x)$ 这个 DP 子矩阵中继续找，对于后者则是 $(n/2,x)-(n/V)$ 这个子矩阵中继续。

注意到这两个子矩阵的大小和为最初 DP 矩阵的一半。重复这个分治过程，直到该矩阵沿 $n$ 维的大小为 1 时结束。

时间复杂度 $T(n,V) = T(n/2,x) + T(n/2,V-x) + O(nV) = O(nV)$。
